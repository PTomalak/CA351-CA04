[
  {
    "user_prompt": "Write the standard header for a simple 6502 program, including basic IO macros, constants, and the program start structure.",
    "expected_response": "; Standard 6502 Program Header and Structure\n\n; --- Constant Definitions (using =) ---\nNEWLINE = $0A      ; ASCII code for Line Feed\nNULL_TERM = $00    ; Null terminator for strings\nMAX_LOOPS = 5      ; Example constant for loop count\nTRUE = $FF         ; Define true value\nFALSE = $00        ; Define false value\n\n; --- Opcode Definitions (Simulated I/O) ---\n; These represent system calls or hardware interaction\nprintnum_opcode   = $72 ; Prints number in Accumulator (Decimal)\nprintchar_opcode  = $B2 ; Prints character in Accumulator (ASCII)\nendprog_opcode    = $D2 ; Halts program execution\n\n; --- Standard Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n; Custom newline macro for convenience\n.macro newline\n    pha                ; Preserve A\n    lda #NEWLINE\n    printchar\n    pla                ; Restore A\n.endmacro\n\n; --- Program Start Address ---\n        .org $0801         ; Common starting point (e.g., C64 BASIC start)\n\n; --- Stack Pointer Initialization ---\ninit_stack:\n    LDX #$FF           ; Load X with $FF (top of stack page $01)\n    TXS                ; Transfer X to Stack Pointer (S = $FF)\n\n; --- Main Program Start Label ---\nstart:\n        ; Main program code begins here\n        NOP                ; Placeholder instruction\n\n        endprog            ; End the program\n\n; --- Data Storage Area ---\n; Define variables and data below the main code\nmy_variable: .res 1         ; Reserve 1 byte for a variable\nmy_string:   .byte \"Init OK\", NULL_TERM ; Example string\n\n        .end               ; End of assembly source file"
  },
  {
    "user_prompt": "Write 6502 code to load the hexadecimal value $4A into the Accumulator and print its decimal equivalent.",
    "expected_response": "; Load Hex $4A and Print Decimal\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$4A           ; Load Accumulator with immediate hex value $4A\n    printnum           ; Print the decimal equivalent (74)\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Generate 6502 code to print the character represented by hexadecimal ASCII code $21.",
    "expected_response": "; Print Character from Hex ASCII ($21 = '!')\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$21            ; Load Accumulator with hex ASCII value for '!'\n    printchar           ; Print the '!' character\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
      "user_prompt": "Store the value 150 (decimal) into the zero page memory location $CC. Then load it back into X and print it.",
      "expected_response": "; Store to Zero Page, Load to X, Print\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_LOC = $CC\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #150           ; Load immediate value 150 (hex $96)\n    STA ZP_LOC         ; Store A into zero page location $CC (STA zp)\n    LDX ZP_LOC         ; Load X register from zero page location $CC (LDX zp)\n    TXA                ; Transfer X to A for printing\n    printnum           ; Print the loaded value (150)\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
      "user_prompt": "Store the value from the Y register (value 77) into absolute memory location 'data_y'.",
      "expected_response": "; Store Y Register to Absolute Memory (STY abs)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDY #77            ; Load Y register with 77 (hex $4D)\n    STY data_y         ; Store Y into memory label 'data_y' (STY abs)\n\n    ; Verify by loading back to A and printing\n    LDA data_y         ; Load A from 'data_y'\n    printnum           ; Print 77\n    endprog\n\n; --- Data Storage ---\ndata_y: .res 1      ; Reserve 1 byte for 'data_y'\n\n        .end"
  },
  {
    "user_prompt": "Transfer the value from the Accumulator (A=10) to the Y register (TAY), then transfer it back to A (TYA) and print.",
    "expected_response": "; Transfer A to Y (TAY) and Y to A (TYA)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #10            ; Load A with 10 ($0A)\n    TAY                ; Transfer A to Y (Y=10)\n    LDA #0             ; Change A to demonstrate transfer works\n    TYA                ; Transfer Y back to A (A=10)\n    printnum           ; Print 10\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Transfer the Stack Pointer (S) value to X (TSX) after initializing it to $FD, then transfer X to A (TXA) and print.",
    "expected_response": "; Initialize Stack Pointer and Print its Value (TXS, TSX)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FD           ; Load X with initial stack value $FD\n    TXS                ; Transfer X to Stack Pointer (S=$FD)\n\n    ; Now read it back\n    TSX                ; Transfer Stack Pointer (S) to X (X=$FD)\n    TXA                ; Transfer X to A for printing\n    printnum           ; Print 253 (value of S)\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Add the value $30 (hex) to the value $45 (hex) stored in memory location 'operand1'. Print the decimal result.",
    "expected_response": "; Add Immediate Hex to Absolute Memory Hex ($30 + $45 = $75)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$45           ; Load value $45 into A\n    STA operand1       ; Store it in memory location 'operand1'\n\n    LDA #$30           ; Load the other value $30 into A\n    CLC                ; Clear Carry flag (important before ADC)\n    ADC operand1       ; Add value from 'operand1' ($45) to A ($30). ADC abs.\n                       ; A = $30 + $45 + 0 = $75\n    printnum           ; Print decimal result (117)\n    endprog\n\n; --- Data Storage ---\noperand1: .res 1\n\n        .end"
  },
  {
    "user_prompt": "Subtract 50 (decimal) from 20 (decimal). Print the result (which will be negative, represented as $E2).",
    "expected_response": "; Subtraction Resulting in Negative ($14 - $32 = $E2)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #20            ; Load 20 (hex $14)\n    SEC                ; Set Carry flag (important before SBC for no borrow)\n    SBC #50            ; Subtract 50 (hex $32).\n                       ; A = $14 - $32 - (1-C) = 20 - 50 - (1-1) = -30\n                       ; A = $E2 (226 decimal, represents -30 signed)\n                       ; Carry flag will be clear (borrow occurred).\n    printnum           ; Print 226\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Increment the value in zero page location $50 (initially 254) using INC zp. Print the result (255). Increment again and print (0).",
    "expected_response": "; Increment Zero Page Memory (INC zp) with Wrap-around\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_INC = $50\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #254           ; Initial value $FE\n    STA ZP_INC         ; Store in ZP $50\n\n    INC ZP_INC         ; Increment ZP $50 ($FE -> $FF). Z=0.\n    LDA ZP_INC\n    printnum           ; Print 255\n    newline\n\n    INC ZP_INC         ; Increment ZP $50 ($FF -> $00). Z=1.\n    LDA ZP_INC\n    printnum           ; Print 0\n    newline\n    endprog\n\n; No data storage in program area needed for ZP\n        .end"
  },
   {
    "user_prompt": "Decrement the value in absolute memory 'counter_abs' (initially 1) using DEC abs. Print the result (0).",
    "expected_response": "; Decrement Absolute Memory (DEC abs)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #1             ; Load 1\n    STA counter_abs    ; Initialize memory 'counter_abs' to 1\n\n    DEC counter_abs    ; Decrement the value at the absolute address (1 -> 0). Sets Z=1.\n\n    LDA counter_abs    ; Load the result (0)\n    printnum           ; Print 0\n    endprog\n\n; --- Data Storage ---\ncounter_abs: .res 1\n\n        .end"
  },
   {
    "user_prompt": "Increment the X register 5 times starting from 0 and print the final value (5).",
    "expected_response": "; Increment X Register Multiple Times (INX)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #$00           ; Load X with 0\n    INX                ; X = 1\n    INX                ; X = 2\n    INX                ; X = 3\n    INX                ; X = 4\n    INX                ; X = 5\n    TXA                ; Transfer X to A for printing\n    printnum           ; Print 5\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Decrement the Y register 3 times starting from 3 and print the final value (0).",
    "expected_response": "; Decrement Y Register Multiple Times (DEY)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDY #$03           ; Load Y with 3\n    DEY                ; Y = 2\n    DEY                ; Y = 1\n    DEY                ; Y = 0. Sets Z=1.\n    TYA                ; Transfer Y to A for printing\n    printnum           ; Print 0\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Add the value in zero page location $88 (value 10) to the accumulator (initially 5) using Zero Page, X addressing, where X=0. Print the result.",
    "expected_response": "; Add Zero Page Indexed Memory to Accumulator (ADC zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_BASE_ADD = $88\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #10            ; Load addend value 10\n    STA ZP_BASE_ADD    ; Store it in zero page $88\n\n    LDA #5             ; Load initial Accumulator value 5\n    LDX #0             ; Set index X to 0\n    CLC                ; Clear Carry before addition\n    ADC ZP_BASE_ADD,X  ; Add value from ZP ($88 + X = $88) to A (5).\n                       ; A = 5 + 10 + 0 = 15 ($0F). ADC zp,X\n    printnum           ; Print 15\n    endprog\n\n; No data storage in program area needed for ZP variables\n        .end"
  },
  {
    "user_prompt": "Subtract the value from absolute memory location 'values'+Y (value at index 1 is 20) from the Accumulator (initially 100), where Y=1. Print the result.",
    "expected_response": "; Subtract Absolute Indexed Memory from Accumulator (SBC abs,Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #100           ; Load initial Accumulator value 100 ($64)\n    LDY #1             ; Set index Y to 1\n    SEC                ; Set Carry before subtraction (no borrow)\n    SBC values,Y       ; Subtract value from 'values + Y' (values[1]=20) from A (100).\n                       ; A = 100 - 20 - (1-C) = 100 - 20 - 0 = 80 ($50)\n                       ; SBC abs,Y. Carry remains set (no borrow needed).\n    printnum           ; Print 80\n    endprog\n\n; --- Data Storage ---\nvalues: .byte 10, 20, 30\n\n        .end"
  },
  {
    "user_prompt": "Write a loop that prints numbers 5 down to 1 using the X register and BNE.",
    "expected_response": "; Loop 5 down to 1 using X and BNE\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #5             ; Initialize loop counter X to 5\nloop_start:\n    TXA                ; Transfer X to A for printing\n    printnum           ; Print current value of X (5, 4, 3, 2, 1)\n    newline\n    DEX                ; Decrement X. Z flag set when X becomes 0.\n    BNE loop_start     ; Branch to 'loop_start' if X is Not Equal to zero (Z=0)\n                       ; Loop continues until X becomes 0 after DEX.\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Write a loop that prints numbers 0 up to 3 using the Y register, CPY, and BNE.",
    "expected_response": "; Loop 0 up to 3 using Y, CPY, BNE\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nUPPER_LIMIT = 4 ; Loop while Y < 4\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDY #0             ; Initialize loop counter Y to 0\nloop_start:\n    TYA                ; Transfer Y to A for printing\n    printnum           ; Print current value of Y (0, 1, 2, 3)\n    newline\n    INY                ; Increment Y\n    CPY #UPPER_LIMIT   ; Compare Y with 4. Sets Z if equal.\n    BNE loop_start     ; Branch if Not Equal (Z=0, Y != 4). Loop continues.\n                       ; Loop terminates when Y equals 4 (Z=1).\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Compare A (value 5) with immediate 10. If A is less than 10, print 'L' using BCC.",
    "expected_response": "; Compare A with Immediate (Less Than Check using BCC)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #5             ; Load 5 ($05)\n    CMP #10            ; Compare A with immediate value 10 ($0A)\n                       ; 5 < 10, so Carry flag is CLEAR (C=0). Z=0, N=1 (result 5-10 is neg).\n    BCC is_less        ; Branch if Carry Clear (A < 10). Takes the branch.\n\n; is_ge:\n    LDA #'G'            ; Skipped: Would execute if A >= 10 (Carry was set)\n    printchar\n    JMP done\n\nis_less:\n    LDA #'L'            ; Executed: A < 10 (Carry was clear)\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Compare X (value 20) with value in ZP location $A0 (value 15). If X is greater or equal, print 'X' using BCS.",
    "expected_response": "; Compare X with Zero Page (Greater/Equal Check using BCS)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_COMPARE = $A0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #15\n    STA ZP_COMPARE     ; Store 15 in ZP $A0\n\n    LDX #20            ; Load 20 ($14) into X\n    CPX ZP_COMPARE     ; Compare X with value at ZP $A0 (15). CPX zp.\n                       ; 20 >= 15, so Carry flag is SET (C=1). Z=0, N=0.\n    BCS is_ge          ; Branch if Carry Set (X >= 15). Takes the branch.\n\n; is_less:\n    LDA #'S'            ; Skipped: Would execute if X < 15 (Carry was clear)\n    printchar\n    JMP done\n\nis_ge:\n    LDA #'X'            ; Executed: X >= 15 (Carry was set)\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Demonstrate the JMP absolute instruction by jumping to a label 'skip_print'.",
    "expected_response": "; Unconditional Jump Absolute (JMP abs)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #'1'\n    printchar\n    JMP skip_print     ; Jump directly to the label 'skip_print'\n\n    ; This code will be skipped due to the JMP\n    LDA #'X'           ; This 'X' will not be printed\n    printchar\n\nskip_print:\n    LDA #'2'           ; Code execution resumes here\n    printchar\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Demonstrate the JMP indirect instruction. Store the address of label 'target' in memory locations $0200/$0201, then jump using JMP ($0200).",
    "expected_response": "; Unconditional Jump Indirect (JMP ind)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nJMP_VECTOR = $0200 ; Address holding the target address (must be in RAM, not ZP here)\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store the address of 'target' into JMP_VECTOR ($0200/$0201)\n    LDA #<target       ; Load low byte of target's address\n    STA JMP_VECTOR     ; Store low byte at $0200\n    LDA #>target       ; Load high byte of target's address\n    STA JMP_VECTOR+1   ; Store high byte at $0201\n\n    LDA #'J'\n    printchar\n    JMP (JMP_VECTOR)   ; Jump to the address stored at $0200/$0201\n\n    ; Code here is skipped by the JMP\n    LDA #'S'\n    printchar\n\ntarget:\n    LDA #'T'           ; Execution lands here\n    printchar\n    endprog\n\n; No data storage needed directly in program area, but uses RAM at $0200/$0201\n        .end"
  },
  {
    "user_prompt": "Store the value from X (55) into absolute memory indexed by Y. Use address 'buffer' and Y=3.",
    "expected_response": "; Store X to Absolute,Y Indexed Memory (STX abs,Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #55            ; Value to store ($37)\n    LDY #3             ; Index = 3\n    STX buffer,Y       ; Store X into address (buffer + Y). STX abs,Y.\n                       ; Stores 55 at buffer[3].\n\n    ; Verify\n    LDA buffer+3       ; Load from buffer[3]\n    printnum           ; Print 55\n    endprog\n\n; --- Data Storage ---\nbuffer: .res 10      ; Reserve 10 bytes for buffer\n\n        .end"
  },
  {
    "user_prompt": "Store the value from Y (66) into zero page memory indexed by X. Use ZP address $D0 and X=2.",
    "expected_response": "; Store Y to Zero Page,X Indexed Memory (STY zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_BUF = $D0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDY #66            ; Value to store ($42)\n    LDX #2             ; Index = 2\n    STY ZP_BUF,X       ; Store Y into ZP address (ZP_BUF + X). STY zp,X.\n                       ; Stores 66 at $D0 + 2 = $D2.\n\n    ; Verify\n    LDA ZP_BUF+2       ; Load from $D2\n    printnum           ; Print 66\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Load the X register from absolute memory indexed by Y. Use address 'settings' and Y=1. Print the value.",
    "expected_response": "; Load X from Absolute,Y Indexed Memory (LDX abs,Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDY #1             ; Index = 1\n    LDX settings,Y     ; Load X from address (settings + Y). LDX abs,Y.\n                       ; Loads settings[1] = 128.\n\n    TXA                ; Transfer X to A for printing\n    printnum           ; Print 128\n    endprog\n\n; --- Data Storage ---\nsettings: .byte 10, 128, 255\n\n        .end"
  },
  {
    "user_prompt": "Load the Y register from zero page memory indexed by X. Use ZP address $E0 and X=3. Print the value.",
    "expected_response": "; Load Y from Zero Page,X Indexed Memory (LDY zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_ARRAY = $E0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize ZP array for the example\n    LDA #11\n    STA ZP_ARRAY+0\n    LDA #22\n    STA ZP_ARRAY+1\n    LDA #33\n    STA ZP_ARRAY+2\n    LDA #44\n    STA ZP_ARRAY+3\n\n    LDX #3             ; Index = 3\n    LDY ZP_ARRAY,X     ; Load Y from ZP address (ZP_ARRAY + X). LDY zp,X.\n                       ; Loads from $E0 + 3 = $E3, which holds 44.\n\n    TYA                ; Transfer Y to A for printing\n    printnum           ; Print 44\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Perform bitwise AND using (Indirect,X) addressing. A = $FF, ZP pointer at $C0 points to 'mask_val' ($AA), X=0. Print result.",
    "expected_response": "; Bitwise AND with (Indirect,X) Addressing (AND (ind,X))\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_PTR = $C0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'mask_val' in ZP $C0/$C1\n    LDA #<mask_val     ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>mask_val     ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$FF           ; Load A with %11111111\n    LDX #0             ; Index X = 0\n    ; Calculate effective address: ZP_PTR+X = $C0. Read word ptr from $C0/$C1.\n    ; Effective address = address(mask_val)\n    AND (ZP_PTR,X)     ; AND A with value at effective address (mask_val = $AA)\n                       ; A = $FF & $AA = $AA\n    printnum           ; Print 170 ($AA)\n    endprog\n\n; --- Data Storage ---\nmask_val: .byte $AA     ; %10101010\n\n        .end"
  },
  {
    "user_prompt": "Perform bitwise EOR using (Indirect),Y addressing. A = $CC, ZP pointer at $D0 points to 'data_bytes', Y=1. data_bytes[1] is $55. Print result.",
    "expected_response": "; Bitwise EOR with (Indirect),Y Addressing (EOR (ind),Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_PTR = $D0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'data_bytes' in ZP $D0/$D1\n    LDA #<data_bytes   ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>data_bytes   ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$CC           ; Load A with %11001100\n    LDY #1             ; Index Y = 1\n    ; Calculate effective address: Read base ptr from $D0/$D1 = address(data_bytes).\n    ; Effective address = base ptr + Y = address(data_bytes) + 1.\n    EOR (ZP_PTR),Y     ; EOR A with value at effective address (data_bytes[1] = $55)\n                       ; A = $CC ^ $55 = $99 (%10011001)\n    printnum           ; Print 153 ($99)\n    endprog\n\n; --- Data Storage ---\ndata_bytes: .byte $AA, $55, $FF\n\n        .end"
  },
  {
    "user_prompt": "Store the Accumulator value ($11) using (Indirect,X) addressing. ZP pointer at $B0 points to 'target_mem', X=0.",
    "expected_response": "; Store Accumulator with (Indirect,X) Addressing (STA (ind,X))\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_PTR = $B0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'target_mem' in ZP $B0/$B1\n    LDA #<target_mem   ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>target_mem   ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$11           ; Value to store\n    LDX #0             ; Index X = 0\n    ; Calculate effective address: ZP_PTR+X = $B0. Read word ptr from $B0/$B1.\n    ; Effective address = address(target_mem)\n    STA (ZP_PTR,X)     ; Store A ($11) to the effective address\n\n    ; Verify\n    LDA target_mem     ; Load from target_mem\n    printnum           ; Should print 17 ($11)\n    endprog\n\n; --- Data Storage ---\ntarget_mem: .res 1\n\n        .end"
  },
  {
    "user_prompt": "Store the Accumulator value ($22) using (Indirect),Y addressing. ZP pointer at $A0 points to 'data_array', Y=2.",
    "expected_response": "; Store Accumulator with (Indirect),Y Addressing (STA (ind),Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_PTR = $A0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'data_array' in ZP $A0/$A1\n    LDA #<data_array   ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>data_array   ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$22           ; Value to store\n    LDY #2             ; Index Y = 2\n    ; Calculate effective address: Read base ptr from $A0/$A1 = address(data_array).\n    ; Effective address = base ptr + Y = address(data_array) + 2.\n    STA (ZP_PTR),Y     ; Store A ($22) to the effective address (data_array[2])\n\n    ; Verify\n    LDA data_array+2   ; Load from data_array[2]\n    printnum           ; Should print 34 ($22)\n    endprog\n\n; --- Data Storage ---\ndata_array: .byte 0, 0, 0, 0\n\n        .end"
  },
  {
    "user_prompt": "Shift the value $01 left arithmetically (ASL A) 4 times and print the result ($10).",
    "expected_response": "; Arithmetic Shift Left Accumulator (ASL A) Multiple Times\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$01           ; Load 1 (%00000001)\n    ASL A              ; A = $02 (%00000010), C=0\n    ASL A              ; A = $04 (%00000100), C=0\n    ASL A              ; A = $08 (%00001000), C=0\n    ASL A              ; A = $10 (%00010000), C=0\n    printnum           ; Prints 16\n    endprog\n\n; No data storage needed\n        .end"
  },
   {
    "user_prompt": "Shift the value $F0 logically right (LSR A) 4 times and print the result ($0F).",
    "expected_response": "; Logical Shift Right Accumulator (LSR A) Multiple Times\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$F0           ; Load 240 (%11110000)\n    LSR A              ; A = $78 (%01111000), C=0\n    LSR A              ; A = $3C (%00111100), C=0\n    LSR A              ; A = $1E (%00011110), C=0\n    LSR A              ; A = $0F (%00001111), C=0\n    printnum           ; Prints 15\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Rotate the value $AA left (ROL A) once with Carry initially clear. Print the result.",
    "expected_response": "; Rotate Left Accumulator (ROL A) Example (Carry=0)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$AA           ; Load %10101010\n    CLC                ; Ensure Carry is clear (0)\n    ROL A              ; Rotate left. Bit 7(1) -> C. Bit 0 <- C(0).\n                       ; A = %01010100 ($54), Carry=1\n    printnum           ; Prints 84 ($54)\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Rotate the value $55 right (ROR A) once with Carry initially set. Print the result.",
    "expected_response": "; Rotate Right Accumulator (ROR A) Example (Carry=1)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$55           ; Load %01010101\n    SEC                ; Ensure Carry is set (1)\n    ROR A              ; Rotate right. Bit 0(1) -> C. Bit 7 <- C(1).\n                       ; A = %10101010 ($AA), Carry=1\n    printnum           ; Prints 170 ($AA)\n    endprog\n\n; No data storage needed\n        .end"
  },
   {
    "user_prompt": "Push A ($11), then X ($22), then Y ($33) onto the stack. Then pull them back into Y, X, A respectively and print A.",
    "expected_response": "; Stack Push/Pull Multiple Registers (Order Matters)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer to $FF\n    TXS                ; S = $FF\n\n    LDA #$11\n    LDX #$22\n    LDY #$33\n\n    PHA                ; Push A ($11). Stack: [$11]. S = $FE\n    TXA                ; Transfer X ($22) to A\n    PHA                ; Push X ($22). Stack: [$22, $11]. S = $FD\n    TYA                ; Transfer Y ($33) to A\n    PHA                ; Push Y ($33). Stack: [$33, $22, $11]. S = $FC\n\n    ; Clear registers to show pull works\n    LDA #0\n    LDX #0\n    LDY #0\n\n    PLA                ; Pull into A ($33). Stack: [$22, $11]. S = $FD\n    TAY                ; Transfer to Y (Y=$33)\n    PLA                ; Pull into A ($22). Stack: [$11]. S = $FE\n    TAX                ; Transfer to X (X=$22)\n    PLA                ; Pull into A ($11). Stack: []. S = $FF\n                       ; A now holds the original A value\n\n    printnum           ; Print 17 ($11)\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Define a 16-bit address table 'jump_table' containing addresses of 'routine1' and 'routine2'. Jump to the second routine using indirect addressing.",
    "expected_response": "; Jump Table using .word and JMP indirect\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nJUMP_INDEX_PTR = $0200 ; Pointer holding the address *of the address* in the table\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Set up pointer to the second entry's address within the jump table\n    ; Second entry (index 1) starts at jump_table + 2 bytes offset.\n    LDA #<(jump_table+2) ; Low byte of address OF routine2's entry in table\n    STA JUMP_INDEX_PTR\n    LDA #>(jump_table+2) ; High byte of address OF routine2's entry in table\n    STA JUMP_INDEX_PTR+1\n\n    JMP (JUMP_INDEX_PTR) ; Jump indirect. Reads address FROM $0200/$0201 (which is address of routine2)\n                         ; and jumps TO routine2.\n\nroutine1:\n    LDA #'1'\n    printchar\n    endprog ; Should not be reached\n\nroutine2:\n    LDA #'2'\n    printchar\n    endprog ; Execution should end here\n\n; --- Data Storage ---\njump_table:\n    .word routine1     ; Store address of routine1 (low byte, high byte)\n    .word routine2     ; Store address of routine2 (low byte, high byte)\n\n        .end"
  },
  {
    "user_prompt": "Calculate 6 * 3 using repeated addition and a subroutine.",
    "expected_response": "; Multiplication by Repeated Addition using Subroutine\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nMULTIPLICAND = 6\nMULTIPLIER   = 3\nTEMP_STORAGE = $00 ; Use ZP $00 for temporary storage\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #MULTIPLICAND  ; Pass multiplicand in A\n    LDX #MULTIPLIER    ; Pass multiplier in X\n    JSR multiply       ; Call multiply subroutine\n    ; Result will be returned in A\n    printnum           ; Print 18\n    endprog\n\n; --- Subroutine: multiply ---\n; Input: A = multiplicand, X = multiplier\n; Output: A = result\n; Clobbers: A, X, Flags, ZP TEMP_STORAGE\n; Assumes result fits in 8 bits and multiplier >= 0.\nmultiply:\n    STA TEMP_STORAGE   ; Store multiplicand temporarily in ZP $00\n    LDA #0             ; Initialize result in A to 0\n    CPX #0             ; Check if multiplier is already zero\n    BEQ mult_done      ; If so, result is 0, skip loop\nmult_loop:\n    CLC                ; Clear carry before adding\n    ADC TEMP_STORAGE   ; Add multiplicand (from ZP) to result in A\n    DEX                ; Decrement multiplier count in X\n    BNE mult_loop      ; Loop again if multiplier (X) is not yet zero\nmult_done:\n    RTS                ; Return with result in A\n\n; Uses ZP $00 temporarily\n; No data storage needed in program area\n        .end"
  },
  {
    "user_prompt": "Print the hexadecimal representation of the decimal number 255.",
    "expected_response": "; Print Decimal 255 in Hexadecimal (FF)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n; Custom macro to print A in hex\n.macro printhex\n    pha                ; Save A, X, Y on stack\n    txa\n    pha\n    tya\n    pha\n\n    tax                ; Save original A in X temporarily\n\n    ; Print high nibble\n    lsr A              ; Shift high nibble into low nibble position\n    lsr A\n    lsr A\n    lsr A\n    tay                ; Use low nibble (original high nibble) as index Y\n    lda hex_digits,Y   ; Load corresponding hex character\n    printchar          ; Print high hex digit\n\n    ; Print low nibble\n    txa                ; Restore original A from X\n    and #$0F           ; Mask out high nibble, keep low nibble\n    tay                ; Use low nibble as index Y\n    lda hex_digits,Y   ; Load corresponding hex character\n    printchar          ; Print low hex digit\n\n    pla                ; Restore Y from stack\n    tay\n    pla                ; Restore X from stack\n    tax\n    pla                ; Restore A from stack\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #255           ; Load decimal 255 ($FF)\n    printhex           ; Use macro to print hexadecimal 'FF'\n    endprog\n\n; --- Data Storage ---\nhex_digits: .byte \"0123456789ABCDEF\"\n\n        .end"
  },
  {
    "user_prompt": "Check if the value in the Accumulator (A=$80) is negative using BMI.",
    "expected_response": "; Check Negative Flag (N) using BMI\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$80           ; Load -128 (Bit 7 is 1)\n                       ; LDA sets N=1 because bit 7 is 1.\n    BMI is_neg         ; Branch if Minus (N=1). Takes the branch.\n\nis_pos_zero:\n    LDA #'P'            ; Skipped: Would execute if N=0\n    printchar\n    JMP done\nis_neg:\n    LDA #'N'            ; Executed: N=1, print 'N'\n    printchar\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Check if the value in the Accumulator (A=$7F) is positive or zero using BPL.",
    "expected_response": "; Check Negative Flag (N) using BPL\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$7F           ; Load 127 (Bit 7 is 0)\n                       ; LDA sets N=0 because bit 7 is 0.\n    BPL is_pos_zero    ; Branch if Plus (N=0). Takes the branch.\n\nis_neg:\n    LDA #'N'            ; Skipped: Would execute if N=1\n    printchar\n    JMP done\nis_pos_zero:\n    LDA #'P'            ; Executed: N=0, print 'P'\n    printchar\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Perform an addition (100+100) that sets the Overflow flag (V=1) and check it using BVS.",
    "expected_response": "; Check Overflow Flag (V) using BVS\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #100           ; Load 100 ($64, positive signed)\n    CLC\n    ADC #100           ; Add 100 ($64, positive signed). Result is 200 ($C8, negative signed).\n                       ; Signed: positive + positive = negative -> Overflow SET (V=1).\n    BVS overflow_happened ; Branch if Overflow Set (V=1). Takes the branch.\n\noverflow_clear:\n    LDA #'O'            ; Skipped: Would execute if V=0\n    printchar\n    JMP done\noverflow_happened:\n    LDA #'V'            ; Executed: V=1, print 'V'\n    printchar\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Perform an addition (50+50) that does not set the Overflow flag (V=0) and check it using BVC.",
    "expected_response": "; Check Overflow Flag (V) using BVC\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #50            ; Load 50 ($32, positive signed)\n    CLC\n    ADC #50            ; Add 50 ($32, positive signed). Result is 100 ($64, positive signed).\n                       ; Signed: positive + positive = positive -> Overflow CLEAR (V=0).\n    BVC overflow_clear   ; Branch if Overflow Clear (V=0). Takes the branch.\n\noverflow_happened:\n    LDA #'V'            ; Skipped: Would execute if V=1\n    printchar\n    JMP done\noverflow_clear:\n    LDA #'C'            ; Executed: V=0, print 'C'\n    printchar\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Define an array 'scores' with values 10, 20, 30 using .byte. Load the element at index 2 (30) using LDA abs,X and print it.",
    "expected_response": "; Access Array Element using Absolute,X (LDA abs,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #2             ; Index = 2\n    LDA scores,X       ; Load from scores + X (scores[2])\n    printnum           ; Print 30\n    endprog\n\n; --- Data Storage ---\nscores: .byte 10, 20, 30\n\n        .end"
  },
  {
    "user_prompt": "Store the value 99 into the array 'buffer' at index 4 using STA abs,Y.",
    "expected_response": "; Store into Array Element using Absolute,Y (STA abs,Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #99            ; Value to store ($63)\n    LDY #4             ; Index = 4\n    STA buffer,Y       ; Store A into buffer + Y (buffer[4])\n\n    ; Verify\n    LDA buffer+4       ; Load from buffer[4]\n    printnum           ; Print 99\n    endprog\n\n; --- Data Storage ---\nbuffer: .res 8         ; Reserve 8 bytes\n\n        .end"
  },
  {
    "user_prompt": "Compare the value in Y (10) with the absolute memory location 'limit_val' (10). Branch to 'equal_label' if they are equal using CPY abs and BEQ.",
    "expected_response": "; Compare Y with Absolute Memory (CPY abs / BEQ)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #10\n    STA limit_val      ; Initialize memory 'limit_val' to 10\n\n    LDY #10            ; Load Y with 10\n    CPY limit_val      ; Compare Y with 'limit_val'. 10 == 10, sets Z=1.\n    BEQ equal_label    ; Branch if Zero flag is set (Y == limit_val). Takes branch.\n\nnot_equal_label:\n    LDA #'N'            ; Skipped: Not equal\n    printchar\n    JMP done\n\nequal_label:\n    LDA #'E'            ; Executed: Equal\n    printchar\n\ndone:\n    newline\n    endprog\n\n; --- Data Storage ---\nlimit_val: .res 1\n\n        .end"
  },
  {
    "user_prompt": "Multiply the value in A (value 15) by 2 using ASL A and print the result.",
    "expected_response": "; Multiply by 2 using ASL A\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #15            ; Load 15 ($0F)\n    ASL A              ; Arithmetic Shift Left (multiplies by 2). A = 30 ($1E), C=0.\n    printnum           ; Print 30\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Multiply the value in memory location 'value_mem' (value 25) by 4 using ASL abs twice. Print the result.",
    "expected_response": "; Multiply Memory Value by 4 using ASL abs\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #25\n    STA value_mem      ; Initialize memory to 25 ($19)\n\n    ASL value_mem      ; Shift memory left (25 * 2 = 50, $32), C=0.\n    ASL value_mem      ; Shift memory left again (50 * 2 = 100, $64), C=0.\n\n    LDA value_mem      ; Load the result (100)\n    printnum           ; Print 100\n    endprog\n\n; --- Data Storage ---\nvalue_mem: .res 1\n\n        .end"
  },
  {
    "user_prompt": "Divide the value in A (value 100) by 2 using LSR A and print the result.",
    "expected_response": "; Divide by 2 using LSR A\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #100           ; Load 100 ($64)\n    LSR A              ; Logical Shift Right (divides unsigned by 2). A = 50 ($32), C=0.\n    printnum           ; Print 50\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Divide the value in zero page location $B5 (value 80) by 4 using LSR zp twice. Print the result.",
    "expected_response": "; Divide Zero Page Value by 4 using LSR zp\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_DIV = $B5\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #80\n    STA ZP_DIV         ; Initialize ZP memory to 80 ($50)\n\n    LSR ZP_DIV         ; Shift ZP memory right (80 / 2 = 40, $28), C=0.\n    LSR ZP_DIV         ; Shift ZP memory right again (40 / 2 = 20, $14), C=0.\n\n    LDA ZP_DIV         ; Load the result (20)\n    printnum           ; Print 20\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Mask out the upper 4 bits of the Accumulator (A = $F5) using AND #$0F. Print the result.",
    "expected_response": "; Mask Upper Nibble using AND Immediate\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$F5           ; Load %11110101\n    AND #$0F           ; AND with %00001111 (mask)\n                       ; A = %00000101 ($05)\n    printnum           ; Print 5\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Set the lower 4 bits of the Accumulator (A = $A0) using ORA #$0F. Print the result.",
    "expected_response": "; Set Lower Nibble using ORA Immediate\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$A0           ; Load %10100000\n    ORA #$0F           ; OR with %00001111 (set bits mask)\n                       ; A = %10101111 ($AF)\n    printnum           ; Print 175\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Flip the bits of the Accumulator (A = $5A) using EOR #$FF. Print the result.",
    "expected_response": "; Invert Bits using EOR Immediate\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$5A           ; Load %01011010\n    EOR #$FF           ; EOR with %11111111 (inverts each bit)\n                       ; A = %10100101 ($A5)\n    printnum           ; Print 165\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Test if bit 0 of zero page location $77 (value $FE) is set using BIT zp. Print 'S' if set, 'C' if clear (based on Z flag).",
    "expected_response": "; Test Bit 0 using BIT zp (checking Z flag)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_TEST = $77\nBIT0_MASK = %00000001 ; Mask for bit 0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$FE           ; Value %11111110 (bit 0 is clear)\n    STA ZP_TEST        ; Store in ZP $77\n\n    LDA #BIT0_MASK     ; Load mask to test bit 0\n    BIT ZP_TEST        ; Test ZP $77. A AND M = %00000001 & %11111110 = %00000000\n                       ; Sets Z flag because result is 0. N,V from memory ($FE): N=1, V=1.\n    BEQ bit_is_clear   ; Branch if Zero flag is set (result of AND was 0 -> bit was clear). Takes branch.\n\nbit_is_set:\n    LDA #'S'            ; Skipped: Print 'S' for Set\n    printchar\n    JMP done\n\nbit_is_clear:\n    LDA #'C'            ; Executed: Print 'C' for Clear\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Define a null-terminated string \"Data:\" and print it using a loop with Y register.",
    "expected_response": "; Print Null-Terminated String using Y loop (LDA abs,Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDY #0             ; Initialize index Y to 0\nprint_loop:\n    LDA message,Y      ; Load character from message[Y] (LDA abs,Y)\n    BEQ print_done     ; Branch if character is null terminator ($00, Z=1)\n    printchar          ; Print the character\n    INY                ; Increment index Y\n    JMP print_loop     ; Loop back\nprint_done:\n    newline\n    endprog\n\n; --- Data Storage ---\nmessage: .byte \"Data:\", 0 ; Define the string with null terminator\n\n        .end"
  },
  {
    "user_prompt": "Copy 5 bytes from 'source_data' at $0900 to 'dest_data' at $0A00 using absolute addressing and X index.",
    "expected_response": "; Memory Block Copy (Absolute to Absolute using X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nCOPY_LENGTH = 5\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #0             ; Use X as index/counter, start at 0\ncopy_loop:\n    CPX #COPY_LENGTH   ; Compare index with length\n    BEQ copy_done      ; Branch if X == COPY_LENGTH (Z=1)\n    LDA source_data,X  ; Load from source[X] (LDA abs,X)\n    STA dest_data,X    ; Store to destination[X] (STA abs,X)\n    INX                ; Increment index X\n    JMP copy_loop      ; Loop back\n\ncopy_done:\n    ; Verify by printing first byte of destination\n    LDA dest_data+0\n    printnum           ; Should print 11\n    endprog\n\n; --- Data Storage --- \n; Place data at specific addresses using .org\n        .org $0900\nsource_data: .byte 11, 22, 33, 44, 55\n\n        .org $0A00\ndest_data:   .res COPY_LENGTH\n\n        .end"
  },
  {
    "user_prompt": "Fill a 4-byte zero page buffer starting at $E0 with the hex value $DD.",
    "expected_response": "; Fill Zero Page Buffer (STA zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_BUFFER = $E0\nBUFFER_LEN = 4\nFILL_VAL = $DD\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #FILL_VAL      ; Load the value to fill with ($DD)\n    LDX #0             ; Initialize index X to 0\nfill_loop:\n    CPX #BUFFER_LEN    ; Check if index reached buffer length\n    BEQ fill_done      ; If yes (X==4), done filling\n    STA ZP_BUFFER,X    ; Store fill value at ZP_BUFFER[X] (STA zp,X)\n    INX                ; Increment index X\n    JMP fill_loop      ; Loop back\n\nfill_done:\n    ; Verify by printing last byte (at index 3)\n    LDA ZP_BUFFER+3\n    printnum           ; Should print 221 ($DD)\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Write a subroutine 'clear_zp' that writes 0 to zero page locations $F0-$F3.",
    "expected_response": "; Subroutine to Clear Zero Page Range\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_START = $F0\nCLEAR_LEN = 4\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Fill ZP with non-zero first to show clearing works\n    LDA #$AA\n    STA ZP_START+0\n    STA ZP_START+1\n    STA ZP_START+2\n    STA ZP_START+3\n\n    JSR clear_zp       ; Call the subroutine\n\n    ; Verify one byte after clearing\n    LDA ZP_START+1\n    printnum           ; Should print 0\n    endprog\n\n; --- Subroutine: clear_zp ---\n; Clears ZP locations ZP_START to ZP_START + CLEAR_LEN - 1\n; Clobbers: A, X\nclear_zp:\n    LDA #0             ; Value to write (0)\n    LDX #0             ; Initialize index X\nclear_loop:\n    CPX #CLEAR_LEN     ; Compare index with length\n    BEQ clear_done     ; Branch if done (X == CLEAR_LEN)\n    STA ZP_START,X     ; Store 0 at ZP_START[X] (STA zp,X)\n    INX                ; Increment index X\n    JMP clear_loop     ; Loop back\nclear_done:\n    RTS                ; Return From Subroutine\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Push the flags using PHP, modify flags (SEC), then pull flags using PLP. Check if Carry is restored to its original state (assume it was clear initially).",
    "expected_response": "; Preserve and Restore Flags using PHP/PLP\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    CLC                ; Ensure Carry is initially clear (C=0)\n    PHP                ; Push Processor Status (Flags) onto stack (C=0 pushed)\n\n    SEC                ; Set Carry flag in the processor (C=1)\n    ; Do some work here where flags might change...\n    LDA #1\n    ADC #2             ; A=3, C=0, V=0, N=0, Z=0\n\n    PLP                ; Pull original flags back from stack (C=0 restored)\n\n    ; Check if Carry is now clear as it was originally\n    BCC carry_is_clear ; Branch if Carry Clear (C=0). Should take branch.\n\ncarry_is_set:\n    LDA #'F'            ; Skipped: Failed, carry not restored\n    printchar\n    JMP done\ncarry_is_clear:\n    LDA #'P'            ; Executed: Passed, carry restored\n    printchar\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Add the value in accumulator (A=10) to the value in X register (X=5). Store result in 'sum_ax'.",
    "expected_response": "; Add Accumulator and X Register (using temp memory)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #10            ; Load A = 10\n    LDX #5             ; Load X = 5\n\n    CLC                ; Clear carry for addition\n    STX temp_x         ; Store X (5) temporarily in memory\n    ADC temp_x         ; Add the stored value of X (5) to A (10)\n                       ; A = 10 + 5 + 0 = 15\n    STA sum_ax         ; Store the result (15)\n\n    ; Verify\n    LDA sum_ax\n    printnum           ; Print 15\n    endprog\n\n; --- Data Storage ---\ntemp_x: .res 1         ; Temporary storage for X\nsum_ax: .res 1         ; Storage for the sum\n\n        .end"
  },
  {
    "user_prompt": "Implement a simple delay loop using the X register, counting down from 100.",
    "expected_response": "; Simple Delay Loop using X\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nDELAY_COUNT = 100\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #'S'            ; Print Start\n    printchar\n\n    ; Delay Subroutine Call (Example Usage)\n    JSR delay\n\n    LDA #'E'            ; Print End\n    printchar\n    newline\n    endprog\n\n; --- Subroutine: delay ---\n; Simple delay by counting X down.\n; Clobbers: X\ndelay:\n    LDX #DELAY_COUNT   ; Load delay count into X\ndelay_loop:\n    DEX                ; Decrement X\n    BNE delay_loop     ; Loop until X is 0 (Z=1)\n    RTS                ; Return from subroutine\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Implement a nested delay loop using X and Y registers.",
    "expected_response": "; Nested Delay Loop using X and Y\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nOUTER_COUNT = 10\nINNER_COUNT = 50\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #'S'\n    printchar\n\n    JSR nested_delay\n\n    LDA #'E'\n    printchar\n    newline\n    endprog\n\n; --- Subroutine: nested_delay ---\n; Longer delay using nested loops.\n; Clobbers: X, Y\nnested_delay:\n    LDY #OUTER_COUNT    ; Initialize outer loop counter Y\nouter_loop:\n    LDX #INNER_COUNT    ; Initialize inner loop counter X\ninner_loop:\n    DEX                 ; Decrement inner counter X\n    BNE inner_loop      ; Loop until X is 0\n    DEY                 ; Decrement outer counter Y\n    BNE outer_loop      ; Loop until Y is 0\n    RTS                 ; Return from subroutine\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Define a byte array 'pattern' as $AA, $55, $AA, $55. Print the byte at index 1.",
    "expected_response": "; Define byte array and access element (LDA abs,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #1             ; Index = 1\n    LDA pattern,X      ; Load from pattern[1]\n    printnum           ; Print 85 (decimal for $55)\n    endprog\n\n; --- Data Storage ---\npattern: .byte $AA, $55, $AA, $55\n\n        .end"
  },
  {
    "user_prompt": "Define a word table 'addresses' with values $1000, $2000. Load the second address ($2000) into ZP locations $F0/$F1.",
    "expected_response": "; Define word table and load entry into ZP\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_ADDR_LOW = $F0\nZP_ADDR_HIGH = $F1\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Load low byte of second address ($00 from $2000)\n    LDA addresses+2    ; Index 2 is low byte of second word (addresses[2])\n    STA ZP_ADDR_LOW    ; Store in ZP $F0\n\n    ; Load high byte of second address ($20 from $2000)\n    LDA addresses+3    ; Index 3 is high byte of second word (addresses[3])\n    STA ZP_ADDR_HIGH   ; Store in ZP $F1\n\n    ; Verify by printing the bytes stored in ZP\n    LDA ZP_ADDR_HIGH   ; Load high byte ($20)\n    printnum           ; Print 32\n    LDA #' '\n    printchar\n    LDA ZP_ADDR_LOW    ; Load low byte ($00)\n    printnum           ; Print 0\n    newline\n    endprog\n\n; --- Data Storage ---\naddresses: .word $1000, $2000 ; Stored as low byte, high byte: 00, 10, 00, 20\n\n        .end"
  },
  {
    "user_prompt": "What is the hexadecimal equivalent of decimal 100?",
    "expected_response": "; Hexadecimal Conversion Question\n; Question: What is the hexadecimal equivalent of decimal 100?\n; Answer: $64\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Demonstrate loading decimal 100 and printing it\n    LDA #100           ; Load decimal 100\n    ; In memory, this is represented as the byte $64\n    printnum           ; Print 100\n    newline\n    ; Manually print the hex representation as characters\n    LDA #'$'\n    printchar\n    LDA #'6'\n    printchar\n    LDA #'4'\n    printchar\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Convert the hexadecimal value $BE to its decimal representation.",
    "expected_response": "; Decimal Conversion Question\n; Question: Convert the hexadecimal value $BE to its decimal representation.\n; Answer: 190\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Demonstrate loading hex $BE and printing its decimal value\n    LDA #$BE           ; Load hex $BE\n    printnum           ; Print 190\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Write 6502 code to clear memory location 'flag_byte' to 0.",
    "expected_response": "; Clear Memory Location to Zero (STA abs)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #0             ; Load Accumulator with 0\n    STA flag_byte      ; Store 0 into the memory location 'flag_byte' (STA abs)\n\n    ; Verify\n    LDA flag_byte      ; Load from 'flag_byte'\n    printnum           ; Should print 0\n    endprog\n\n; --- Data Storage ---\nflag_byte: .res 1      ; Reserve 1 byte\n\n        .end"
  },
  {
    "user_prompt": "Check if the value in 'status_reg' is exactly zero. If yes, print 'Z'.",
    "expected_response": "; Check if Memory is Zero using LDA and BEQ\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #0             ; Example: set status_reg to 0\n    STA status_reg\n\n    LDA status_reg     ; Load the value from memory ('status_reg')\n                       ; LDA #0 sets the Zero flag (Z=1).\n    BEQ is_zero        ; Branch if Zero flag is set (A == 0). Takes branch.\n\nnot_zero:\n    LDA #'N'            ; Skipped: Not zero\n    printchar\n    JMP done\nis_zero:\n    LDA #'Z'            ; Executed: Is zero, print 'Z'\n    printchar\ndone:\n    newline\n    endprog\n\n; --- Data Storage ---\nstatus_reg: .res 1     ; Reserve 1 byte\n\n        .end"
  },
   {
    "user_prompt": "Swap the values in two zero page locations, $C0 and $C1, using the X register for temporary storage.",
    "expected_response": "; Swap two Zero Page locations using X\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_VAL1 = $C0\nZP_VAL2 = $C1\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize values\n    LDA #11\n    STA ZP_VAL1        ; ZP $C0 = 11\n    LDA #22\n    STA ZP_VAL2        ; ZP $C1 = 22\n\n    ; Swap using X\n    LDX ZP_VAL1        ; X = value of VAL1 (11) (LDX zp)\n    LDA ZP_VAL2        ; A = value of VAL2 (22) (LDA zp)\n    STA ZP_VAL1        ; VAL1 = A (22)         (STA zp)\n    TXA                ; A = X (original VAL1 = 11)\n    STA ZP_VAL2        ; VAL2 = A (11)         (STA zp)\n\n    ; Verify\n    LDA ZP_VAL1        ; Load VAL1 (should be 22)\n    printnum           ; Print 22\n    newline\n    LDA ZP_VAL2        ; Load VAL2 (should be 11)\n    printnum           ; Print 11\n    newline\n    endprog\n\n; No data storage in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Swap the values in two absolute memory locations, 'varA' and 'varB', using the Accumulator and stack for temporary storage.",
    "expected_response": "; Swap two Absolute Memory locations using Stack\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize values\n    LDA #33\n    STA varA           ; varA = 33\n    LDA #44\n    STA varB           ; varB = 44\n\n    ; Swap using A and Stack\n    LDA varA           ; A = value of varA (33) (LDA abs)\n    PHA                ; Push varA value (33) onto stack\n    LDA varB           ; A = value of varB (44) (LDA abs)\n    STA varA           ; varA = A (44)         (STA abs)\n    PLA                ; Pull original varA value (33) from stack into A\n    STA varB           ; varB = A (33)         (STA abs)\n\n    ; Verify\n    LDA varA           ; Load varA (should be 44)\n    printnum           ; Print 44\n    newline\n    LDA varB           ; Load varB (should be 33)\n    printnum           ; Print 33\n    newline\n    endprog\n\n; --- Data Storage ---\nvarA: .res 1\nvarB: .res 1\n\n        .end"
  },
  {
    "user_prompt": "Write a subroutine 'print_char_x' that prints the character currently in the X register.",
    "expected_response": "; Subroutine to Print Character in X Register\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #'*'           ; Load X with ASCII '*' ($2A)\n    JSR print_char_x   ; Call subroutine to print '*'\n    LDX #'!'           ; Load X with ASCII '!' ($21)\n    JSR print_char_x   ; Call subroutine to print '!'\n    LDA #$0A           ; Print newline after tests\n    printchar\n    endprog\n\n; --- Subroutine: print_char_x ---\n; Prints the character whose ASCII code is in X.\n; Preserves: X, Y\n; Clobbers: A, Flags\nprint_char_x:\n    pha                ; Preserve A on stack\n    TXA                ; Transfer X to A\n    printchar          ; Print the character in A\n    pla                ; Restore A from stack\n    RTS                ; Return From Subroutine\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Write a subroutine 'add_x_y' that adds X and Y registers and returns the result in A. Assume no overflow.",
    "expected_response": "; Subroutine to Add X and Y, Result in A\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nTEMP_FOR_X = $00 ; ZP location for temporary storage\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #10\n    LDY #20\n    JSR add_x_y        ; Call subroutine. A should return 10+20=30.\n    printnum           ; Print 30\n    endprog\n\n; --- Subroutine: add_x_y ---\n; Input: X, Y registers\n; Output: A = X + Y\n; Preserves: X, Y (by saving/restoring X)\n; Clobbers: A, Flags, ZP TEMP_FOR_X\n; Assumes result fits in 8 bits.\nadd_x_y:\n    pha                ; Preserve original A\n    phx                ; Preserve original X\n    phy                ; Preserve original Y\n\n    stx TEMP_FOR_X     ; Store X in a temporary ZP location\n    tya                ; Move Y to A\n    clc                ; Clear carry before addition\n    adc TEMP_FOR_X     ; Add X (from ZP) to A (which holds Y)\n                       ; Result is now in A\n\n    ; A holds the result, which is the intended output\n    ply                ; Restore original Y\n    plx                ; Restore original X\n    ; Leave result in A, restore original A from stack just before returning\n    ; Need to put result somewhere safe if we restore A here.\n    ; Alternative: Don't preserve A if result is returned in A.\n    ; Let's stick to the simpler clobbering approach for basic examples.\n    ; Revised clobbering approach:\n    ; STX TEMP_FOR_X\n    ; TYA\n    ; CLC\n    ; ADC TEMP_FOR_X\n    ; RTS\n\n; --- Revised Subroutine (Simpler, Clobbers A, Flags, ZP) ---\n; Input: X, Y registers\n; Output: A = X + Y\n; Clobbers: A, Flags, ZP TEMP_FOR_X\n; Assumes result fits in 8 bits.\n; add_x_y:\n;     STX TEMP_FOR_X     ; Store X temporarily\n;     TYA                ; Move Y to A\n;     CLC\n;     ADC TEMP_FOR_X     ; Add stored X to A\n;     RTS                ; Return with result A = X+Y\n\n; Using stack to preserve X/Y but return in A:\nadd_x_y:\n    pha                ; Save A\n    txa                ; Move X to A\n    pha                ; Save X on stack\n    tya                ; Move Y to A (A=Y)\n    clc\n    adc (1,S)          ; Add saved X (now at stack pointer + 1) to A\n    ; Result A = Y + X\n    pla                ; Pull saved X off stack (discard)\n    pla                ; Restore original A (discard, A holds result)\n    ; A now contains X+Y\n    rts\n\n\n; Let's use the ZP temporary method as it's slightly clearer\n; and specified as clobbering ZP $00\nadd_x_y_final:\n    STX TEMP_FOR_X     ; Store X temporarily in ZP $00\n    TYA                ; Move Y to A\n    CLC                ; Clear carry for addition\n    ADC TEMP_FOR_X     ; Add X (from ZP) to A (which holds Y)\n    RTS                ; Return with result in A\n\n; Uses ZP $00 temporarily\n; No data storage needed in program area\n        .end"
  },
  {
    "user_prompt": "Load hex $FF into A, print decimal.",
    "expected_response": "; Load Hex $FF, Print Decimal\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$FF           ; Load hex $FF\n    printnum           ; Print decimal 255\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Load decimal 65 into A, print the character.",
    "expected_response": "; Load Decimal 65, Print Character ('A')\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #65            ; Load decimal 65 (ASCII for 'A', hex $41)\n    printchar           ; Print character 'A'\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
      "user_prompt": "Store the value from X ($AA) into zero page location $BB.",
      "expected_response": "; Store X Register to Zero Page (STX zp)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_TARGET = $BB\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #$AA           ; Load X with $AA (170)\n    STX ZP_TARGET      ; Store X into zero page $BB (STX zp)\n\n    ; Verify\n    LDA ZP_TARGET      ; Load from ZP $BB\n    printnum           ; Print 170\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
      "user_prompt": "Store the value from Y ($CC) into zero page location $DD.",
      "expected_response": "; Store Y Register to Zero Page (STY zp)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_TARGET = $DD\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDY #$CC           ; Load Y with $CC (204)\n    STY ZP_TARGET      ; Store Y into zero page $DD (STY zp)\n\n    ; Verify\n    LDA ZP_TARGET      ; Load from ZP $DD\n    printnum           ; Print 204\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Add 1 to the accumulator (A=5) using ADC #1 and print.",
    "expected_response": "; Add 1 using ADC #1\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #5\n    CLC                ; Clear carry is essential for adding just 1\n    ADC #1             ; A = A + 1 + C = 5 + 1 + 0 = 6\n    printnum           ; Print 6\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Subtract 1 from the accumulator (A=10) using SBC #1 and print.",
    "expected_response": "; Subtract 1 using SBC #1\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #10\n    SEC                ; Set carry is essential for subtracting just 1 (no borrow)\n    SBC #1             ; A = A - 1 - (1-C) = 10 - 1 - (1-1) = 9\n    printnum           ; Print 9\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Loop indefinitely by jumping back to the start label.",
    "expected_response": "; Infinite Loop using JMP abs\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\nloop_forever:\n    LDA #'.'           ; Print something inside the loop to show activity\n    printchar\n    ; Add a small delay (optional, makes output readable)\n    LDY #$80\ndelay_inner:\n    DEY\n    BNE delay_inner\n    JMP loop_forever   ; Jump back to the beginning of the loop\n\n    ; This endprog command will never be reached in a real execution\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Perform ORA using (Indirect,X) addressing. A = $0F, ZP pointer at $90 points to 'or_val' ($55), X=0. Print result.",
    "expected_response": "; Bitwise ORA with (Indirect,X) Addressing (ORA (ind,X))\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_PTR = $90\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'or_val' in ZP $90/$91\n    LDA #<or_val       ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>or_val       ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$0F           ; Load A with %00001111\n    LDX #0             ; Index X = 0\n    ; Calculate effective address: ZP_PTR+X = $90. Read word ptr from $90/$91.\n    ; Effective address = address(or_val)\n    ORA (ZP_PTR,X)     ; ORA A with value at effective address (or_val = $55)\n                       ; A = $0F | $55 = $5F (%01011111)\n    printnum           ; Print 95 ($5F)\n    endprog\n\n; --- Data Storage ---\nor_val: .byte $55     ; %01010101\n\n        .end"
  },
  {
    "user_prompt": "Perform ADC using (Indirect),Y addressing. A = $10, ZP pointer at $80 points to 'add_array', Y=2. add_array[2] is $30. Print result.",
    "expected_response": "; Add with Carry with (Indirect),Y Addressing (ADC (ind),Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_PTR = $80\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'add_array' in ZP $80/$81\n    LDA #<add_array    ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>add_array    ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$10           ; Load A with %00010000\n    LDY #2             ; Index Y = 2\n    CLC                ; Clear Carry before addition\n    ; Calculate effective address: Read base ptr from $80/$81 = address(add_array).\n    ; Effective address = base ptr + Y = address(add_array) + 2.\n    ADC (ZP_PTR),Y     ; ADC A with value at effective address (add_array[2] = $30)\n                       ; A = $10 + $30 + 0 = $40 (%01000000)\n    printnum           ; Print 64 ($40)\n    endprog\n\n; --- Data Storage ---\nadd_array: .byte $10, $20, $30, $40\n\n        .end"
  },
   {
    "user_prompt": "Perform SBC using (Indirect,X) addressing. A = $50, ZP pointer at $70 points to 'sub_val' ($20), X=0. Print result.",
    "expected_response": "; Subtract with Carry with (Indirect,X) Addressing (SBC (ind,X))\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_PTR = $70\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'sub_val' in ZP $70/$71\n    LDA #<sub_val      ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>sub_val      ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$50           ; Load A with %01010000\n    LDX #0             ; Index X = 0\n    SEC                ; Set Carry before subtraction (no borrow)\n    ; Calculate effective address: ZP_PTR+X = $70. Read word ptr from $70/$71.\n    ; Effective address = address(sub_val)\n    SBC (ZP_PTR,X)     ; SBC A with value at effective address (sub_val = $20)\n                       ; A = $50 - $20 - (1-C) = 80 - 32 - 0 = 48 ($30)\n    printnum           ; Print 48 ($30)\n    endprog\n\n; --- Data Storage ---\nsub_val: .byte $20\n\n        .end"
  },
   {
    "user_prompt": "Compare A using (Indirect),Y addressing. A = $AA, ZP pointer at $60 points to 'comp_bytes', Y=1. comp_bytes[1] is $AA. Print 'E' if equal.",
    "expected_response": "; Compare Accumulator with (Indirect),Y Addressing (CMP (ind),Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_PTR = $60\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'comp_bytes' in ZP $60/$61\n    LDA #<comp_bytes   ; Low byte of address\n    STA ZP_PTR+0\n    LDA #>comp_bytes   ; High byte of address\n    STA ZP_PTR+1\n\n    LDA #$AA           ; Load A with value to compare\n    LDY #1             ; Index Y = 1\n    ; Calculate effective address: Read base ptr from $60/$61 = address(comp_bytes).\n    ; Effective address = base ptr + Y = address(comp_bytes) + 1.\n    CMP (ZP_PTR),Y     ; Compare A with value at effective address (comp_bytes[1] = $AA)\n                       ; $AA == $AA, sets Z=1, C=1.\n    BEQ are_equal      ; Branch if Zero flag is set (A == Mem). Takes branch.\n\nnot_equal:\n    LDA #'N'            ; Skipped: Not equal\n    printchar\n    JMP done\nare_equal:\n    LDA #'E'            ; Executed: Equal\n    printchar\ndone:\n    newline\n    endprog\n\n; --- Data Storage ---\ncomp_bytes: .byte $11, $AA, $22\n\n        .end"
  },
  {
    "user_prompt": "Increment memory using INC abs,X. Address 'counters', X=2. Initial value counters[2]=5.",
    "expected_response": "; Increment Memory using Absolute,X (INC abs,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #5\n    STA counters+2     ; Initialize counters[2] = 5\n\n    LDX #2             ; Index = 2\n    INC counters,X     ; Increment memory at counters + X (counters[2])\n                       ; Value becomes 6.\n\n    ; Verify\n    LDA counters+2     ; Load from counters[2]\n    printnum           ; Print 6\n    endprog\n\n; --- Data Storage ---\ncounters: .res 5       ; Reserve 5 bytes\n\n        .end"
  },
  {
    "user_prompt": "Decrement memory using DEC zp,X. ZP Address $D5, X=1. Initial value at $D6=10.",
    "expected_response": "; Decrement Memory using Zero Page,X (DEC zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_BASE = $D5\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #10\n    STA ZP_BASE+1      ; Initialize ZP $D6 = 10\n\n    LDX #1             ; Index = 1\n    DEC ZP_BASE,X      ; Decrement memory at ZP ($D5 + X = $D6)\n                       ; Value becomes 9.\n\n    ; Verify\n    LDA ZP_BASE+1      ; Load from ZP $D6\n    printnum           ; Print 9\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Shift memory left using ASL zp,X. ZP Address $A0, X=3. Initial value at $A3=$41.",
    "expected_response": "; Shift Memory Left using Zero Page,X (ASL zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_SHIFT = $A0\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$41           ; Initial value %01000001\n    STA ZP_SHIFT+3     ; Initialize ZP $A3 = $41\n\n    LDX #3             ; Index = 3\n    ASL ZP_SHIFT,X     ; Shift left memory at ZP ($A0 + X = $A3)\n                       ; Value $41 becomes %10000010 ($82), C=0.\n\n    ; Verify\n    LDA ZP_SHIFT+3     ; Load from ZP $A3\n    printnum           ; Print 130 ($82)\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Shift memory right using LSR abs,X. Address 'shift_data', X=1. Initial value shift_data[1]=$EF.",
    "expected_response": "; Shift Memory Right using Absolute,X (LSR abs,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize data (needed because LSR modifies memory)\n    LDA #$EF\n    STA shift_data+1   ; shift_data[1] = $EF\n\n    LDX #1             ; Index = 1\n    LSR shift_data,X   ; Shift right memory at shift_data + X (shift_data[1])\n                       ; Value $EF (%11101111) becomes %01110111 ($77), C=1.\n\n    ; Verify\n    LDA shift_data+1   ; Load from shift_data[1]\n    printnum           ; Print 119 ($77)\n    endprog\n\n; --- Data Storage ---\nshift_data: .res 4     ; Reserve space, e.g., .byte $CA, $EF, $FE, $ED in original\n                       ; Using .res here as we initialize the relevant byte\n\n        .end"
  },
  {
    "user_prompt": "Rotate memory left using ROL abs,X. Address 'rot_mem', X=0. Initial value rot_mem[0]=$01, Carry=1.",
    "expected_response": "; Rotate Memory Left using Absolute,X (ROL abs,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize data\n    LDA #$01\n    STA rot_mem+0      ; rot_mem[0] = $01\n\n    SEC                ; Set Carry = 1\n    LDX #0             ; Index = 0\n    ROL rot_mem,X      ; Rotate left memory at rot_mem + X (rot_mem[0])\n                       ; Value $01 (%00000001), C=1 -> %00000011 ($03), C=0\n                       ; Bit 0 gets old Carry (1). Bit 7 (0) goes to new Carry.\n\n    ; Verify\n    LDA rot_mem+0      ; Load from rot_mem[0]\n    printnum           ; Print 3 ($03)\n    endprog\n\n; --- Data Storage ---\nrot_mem: .res 3       ; Reserve 3 bytes\n\n        .end"
  },
  {
    "user_prompt": "Rotate memory right using ROR zp,X. ZP Address $E5, X=1. Initial value at $E6=$02, Carry=1.",
    "expected_response": "; Rotate Memory Right using Zero Page,X (ROR zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_ROR = $E5\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$02           ; Initial value %00000010\n    STA ZP_ROR+1       ; Initialize ZP $E6 = $02\n\n    SEC                ; Set Carry = 1\n    LDX #1             ; Index = 1\n    ROR ZP_ROR,X       ; Rotate right memory at ZP ($E5 + X = $E6)\n                       ; Value $02 (%00000010), C=1 -> %10000001 ($81), C=0\n                       ; Bit 7 gets old Carry (1). Bit 0 (0) goes to new Carry.\n\n    ; Verify\n    LDA ZP_ROR+1       ; Load from ZP $E6\n    printnum           ; Print 129 ($81)\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Load the address of 'my_string' into ZP locations $F8 (low) and $F9 (high).",
    "expected_response": "; Store Address in Zero Page Pair\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_PTR_LOW = $F8\nZP_PTR_HIGH = $F9\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #<my_string    ; Load low byte of address of 'my_string'\n    STA ZP_PTR_LOW     ; Store in ZP $F8\n    LDA #>my_string    ; Load high byte of address of 'my_string'\n    STA ZP_PTR_HIGH    ; Store in ZP $F9\n\n    ; Verify (optional - print the address bytes)\n    LDA ZP_PTR_HIGH    ; Load high byte\n    ; Need printhex macro or similar to view hex easily\n    ; Just print decimal for verification\n    printnum           ; prints high byte value (decimal)\n    LDA #' '\n    printchar\n    LDA ZP_PTR_LOW     ; Load low byte\n    printnum           ; prints low byte value (decimal)\n    newline\n\n    endprog\n\n; --- Data Storage ---\nmy_string: .byte \"Address test\", 0\n\n        .end"
  },
  {
    "user_prompt": "Use a loop and indirect indexed addressing (($zp),Y) to print the string whose address is stored in ZP $F8/$F9.",
    "expected_response": "; Print String using (Indirect),Y Addressing (LDA (ind),Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_PTR = $F8 ; Pointer address stored at ZP $F8/$F9\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Store address of 'message' in ZP pointer\n    LDA #<message      ; Low byte of address\n    STA ZP_PTR\n    LDA #>message      ; High byte of address\n    STA ZP_PTR+1\n\n    ; Print using (ZP_PTR),Y\n    LDY #0             ; Initialize index Y = 0\nprint_loop:\n    LDA (ZP_PTR),Y     ; Load character: Base=word at ZP_PTR, Effective=Base+Y\n    BEQ print_done     ; Exit if null terminator (Z=1)\n    printchar          ; Print the character\n    INY                ; Increment index Y\n    JMP print_loop     ; Loop back\n\nprint_done:\n    newline\n    endprog\n\n; --- Data Storage ---\nmessage: .byte \"Indirect Print!\", 0\n\n        .end"
  },
  {
    "user_prompt": "Calculate the length of a null-terminated string 'test_str' and print the length.",
    "expected_response": "; Calculate String Length\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #0             ; Use X as index / length counter, start at 0\nstrlen_loop:\n    LDA test_str,X     ; Load character from string[X] (LDA abs,X)\n    BEQ strlen_done    ; If null terminator ($00), branch to done (Z=1)\n    INX                ; Increment index/length X\n    CPX #255           ; Safety check to prevent runaway loop on non-terminated string\n    BNE strlen_loop    ; If X != 255 (Z=0), loop back\n    ; Optional: If loop finishes due to CPX limit, maybe handle error\nstrlen_done:\n    ; Length is now in X (e.g., if \"Hi\", X will be 2)\n    TXA                ; Transfer length from X to A\n    printnum           ; Print the length\n    newline\n    endprog\n\n; --- Data Storage ---\ntest_str: .byte \"Calculate This\", 0 ; Length = 14\n\n        .end"
  },
   {
    "user_prompt": "Write 6502 code to load 200 into X, store it to ZP $A0, load 100 into Y, store it to ZP $A1. Then load X from $A0 and Y from $A1 and print Y.",
    "expected_response": "; Load/Store X and Y with Zero Page (LDX zp, STX zp, LDY zp, STY zp)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_X_VAL = $A0\nZP_Y_VAL = $A1\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #200           ; Load X with 200 ($C8)\n    STX ZP_X_VAL       ; Store X to ZP $A0 (STX zp)\n    LDY #100           ; Load Y with 100 ($64)\n    STY ZP_Y_VAL       ; Store Y to ZP $A1 (STY zp)\n\n    ; Clear registers to ensure load works\n    LDX #0\n    LDY #0\n\n    LDX ZP_X_VAL       ; Load X back from ZP $A0 (LDX zp). X should be 200.\n    LDY ZP_Y_VAL       ; Load Y back from ZP $A1 (LDY zp). Y should be 100.\n\n    TYA                ; Transfer Y (100) to A for printing\n    printnum           ; Print 100\n    endprog\n\n; No data storage in program area needed for ZP\n        .end"
  },
  {
    "user_prompt": "Check if the Carry flag is set after adding $F0 and $10. Print 'C' if set, 'N' if not.",
    "expected_response": "; Check Carry Flag after Addition using BCS/BCC\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$F0           ; Load 240\n    CLC                ; Clear Carry before adding\n    ADC #$10           ; Add 16. $F0 + $10 = $100.\n                       ; Result $00 in A, Carry=1.\n\n    BCS carry_is_set   ; Branch if Carry Set (C=1). Takes branch.\n\ncarry_is_clear:\n    LDA #'N'            ; Skipped: Carry was not clear\n    printchar\n    JMP done\n\ncarry_is_set:\n    LDA #'C'            ; Executed: Carry was set\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Check if the Carry flag is clear after subtracting $10 from $05. Print 'C' if clear, 'N' if not.",
    "expected_response": "; Check Carry Flag after Subtraction using BCS/BCC\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$05           ; Load 5\n    SEC                ; Set Carry before subtracting (no borrow)\n    SBC #$10           ; Subtract 16. $05 - $10 - (1-C) = 5 - 16 - 0 = -11.\n                       ; Result is $F5 in A. Borrow occurred, Carry=0.\n\n    BCC carry_is_clear ; Branch if Carry Clear (C=0). Takes branch.\n\ncarry_is_set:\n    LDA #'N'            ; Skipped: Carry was not set\n    printchar\n    JMP done\n\ncarry_is_clear:\n    LDA #'C'            ; Executed: Carry was clear\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
   {
    "user_prompt": "Use a loop with Absolute,X addressing to find the first occurrence of the value 0 in the array 'data_search'. Print the index, or 255 if not found.",
    "expected_response": "; Find First Zero in Array using Absolute,X Loop\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nARRAY_LEN = 10\nNOT_FOUND_VAL = 255\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDX #0             ; Initialize index X to 0\nsearch_loop:\n    LDA data_search,X  ; Load element data_search[X] (LDA abs,X)\n    BEQ found_zero     ; If element is zero (Z=1), branch to found_zero\n    INX                ; Increment index X\n    CPX #ARRAY_LEN     ; Compare index with array length\n    BNE search_loop    ; If X != ARRAY_LEN (Z=0), continue searching\n\n; If loop finishes, zero was not found\nnot_found:\n    LDX #NOT_FOUND_VAL ; Load index with 'not found' value (255)\n    JMP print_result   ; Jump to print the result\n\nfound_zero:\n    ; X already holds the index where zero was found\n\nprint_result:\n    TXA                ; Transfer index (found index or 255) from X to A\n    printnum           ; Print the index\n    endprog\n\n; --- Data Storage ---\ndata_search: .byte 10, 20, 5, 0, 30, 40, 8, 9, 1, 7 ; Zero is at index 3\n; index_result: .res 1 ; Result is returned in X/A directly\n\n        .end"
  },
  {
    "user_prompt": "Load the value 5. Check if it is zero using BEQ. If not zero, print 'N'.",
    "expected_response": "; Check if A is Zero using LDA/BEQ\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #5             ; Load a non-zero value\n                       ; LDA #5 sets Z=0.\n    BEQ is_zero        ; Branch if Zero flag is set (A == 0). Does not branch.\n\nnot_zero:\n    LDA #'N'            ; Executed: A is not zero, print 'N'\n    printchar\n    JMP done\n\nis_zero:\n    LDA #'Z'            ; Skipped: Would execute if A was 0\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Load the value 0. Check if it is non-zero using BNE. If non-zero, print 'N'.",
    "expected_response": "; Check if A is Non-Zero using LDA/BNE\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #0             ; Load zero value\n                       ; LDA #0 sets Z=1.\n    BNE is_not_zero    ; Branch if Zero flag is clear (A != 0). Does not branch.\n\nis_zero:\n    LDA #'Z'            ; Executed: A is zero, print 'Z'\n    printchar\n    JMP done\n\nis_not_zero:\n    LDA #'N'            ; Skipped: Would execute if A was non-zero\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Print the ASCII characters for 'H', 'E', 'X'.",
    "expected_response": "; Print Multiple Characters 'HEX'\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #'H'\n    printchar\n    LDA #'E'\n    printchar\n    LDA #'X'\n    printchar\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Disable interrupts using the appropriate 6502 instruction.",
    "expected_response": "; Disable Interrupts (Set Interrupt Disable Flag)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    SEI                ; Set Interrupt Disable flag (I=1)\n                       ; Prevents maskable interrupts (IRQ)\n    ; ... critical section code ...\n    LDA #'I'\n    printchar ; Indicate interrupts disabled (for example)\n    ; CLI                ; Re-enable interrupts later if needed\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Enable interrupts using the appropriate 6502 instruction.",
    "expected_response": "; Enable Interrupts (Clear Interrupt Disable Flag)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; SEI                ; Assume interrupts might have been disabled\n    CLI                ; Clear Interrupt Disable flag (I=0)\n                       ; Allows maskable interrupts (IRQ) to occur\n    LDA #'O'\n    printchar ; Indicate interrupts enabled (for example)\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Clear the overflow flag (V) explicitly.",
    "expected_response": "; Clear Overflow Flag (CLV)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Example: Cause overflow\n    LDA #100\n    ADC #100           ; V flag potentially set here\n    ; Now clear it regardless of previous state\n    CLV                ; Clear Overflow flag (V=0)\n    ; Check with BVC (should always branch now)\n    BVC overflow_clear\n    LDA #'F' ; Fail\n    printchar\n    JMP done\noverflow_clear:\n    LDA #'P' ; Pass\n    printchar\ndone:\n    endprog\n\n; No data storage needed\n        .end"
  },
   {
    "user_prompt": "Load A from zero page location $44 indexed by X, where X=2. Initialize $46 to $AB.",
    "expected_response": "; Load Accumulator using Zero Page,X (LDA zp,X)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_BASE = $44\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize value at ZP $44 + 2 = $46\n    LDA #$AB\n    STA ZP_BASE+2\n\n    LDX #2             ; Index X = 2\n    LDA ZP_BASE,X      ; Load A from ZP address $44 + X = $46\n                       ; A should now be $AB\n    printnum           ; Print 171 ($AB)\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Perform bitwise ORA using Absolute,Y addressing. A=$11, address 'data_values', Y=2. Initialize data_values[2] to $44.",
    "expected_response": "; Bitwise ORA using Absolute,Y (ORA abs,Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize memory\n    LDA #$44\n    STA data_values+2  ; data_values[2] = $44 (%01000100)\n\n    LDA #$11           ; Load A = $11 (%00010001)\n    LDY #2             ; Index Y = 2\n    ORA data_values,Y  ; ORA A with memory at data_values + Y (data_values[2])\n                       ; A = $11 | $44 = %00010001 | %01000100 = %01010101 ($55)\n    printnum           ; Print 85 ($55)\n    endprog\n\n; --- Data Storage ---\ndata_values: .res 5      ; Reserve 5 bytes\n\n        .end"
  },
   {
    "user_prompt": "Compare X ($50) with zero page location $30 indexed by Y ($05). Initialize ZP $35 to $50. Print 'E' if equal.",
    "expected_response": "; Compare X using Zero Page,Y (CPX zp,Y)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_BASE = $30\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize memory\n    LDA #$50\n    STA ZP_BASE+5      ; ZP $35 = $50\n\n    LDX #$50           ; Load X = $50\n    LDY #5             ; Index Y = 5\n    CPX ZP_BASE,Y      ; Compare X with memory at ZP $30 + Y = $35 ($50)\n                       ; $50 == $50, sets Z=1, C=1.\n    BEQ equal_result   ; Branch if equal (Z=1). Takes branch.\n\nnot_equal_result:\n    LDA #'N'\n    printchar\n    JMP done\n\nequal_result:\n    LDA #'E'\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Sum the elements of a byte array 'numbers' (5, 10, 15) and print the result.",
    "expected_response": "; Sum Array Elements using a Loop\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nARRAY_LEN = 3\nSUM_VAR = $00 ; Use ZP $00 to store the sum\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #0             ; Initialize sum to 0\n    STA SUM_VAR\n    LDX #0             ; Initialize index X to 0\nsum_loop:\n    CPX #ARRAY_LEN     ; Check if index reached end of array\n    BEQ sum_done       ; Branch if X == ARRAY_LEN\n    LDA numbers,X      ; Load element numbers[X]\n    CLC                ; Clear carry before adding\n    ADC SUM_VAR        ; Add element to current sum\n    STA SUM_VAR        ; Store updated sum\n    INX                ; Increment index X\n    JMP sum_loop       ; Loop back\n\nsum_done:\n    LDA SUM_VAR        ; Load final sum (5 + 10 + 15 = 30)\n    printnum           ; Print 30\n    endprog\n\n; --- Data Storage ---\nnumbers: .byte 5, 10, 15\n; Uses ZP $00 for sum_var\n\n        .end"
  },
  {
    "user_prompt": "If the value in 'flag' is non-zero, print 'T', otherwise print 'F'. Initialize 'flag' to 1.",
    "expected_response": "; Simple If/Else Check on Memory Value\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize flag\n    LDA #1             ; Set flag to non-zero\n    STA flag\n\n    LDA flag           ; Load the flag value\n                       ; LDA #1 sets Z=0.\n    BEQ is_false       ; Branch if flag is zero (Z=1). Does not branch.\n\nis_true:\n    LDA #'T'            ; Flag was non-zero\n    printchar\n    JMP done\n\nis_false:\n    LDA #'F'            ; Flag was zero\n    printchar\n\ndone:\n    newline\n    endprog\n\n; --- Data Storage ---\nflag: .res 1\n\n        .end"
  },
  {
    "user_prompt": "Load $95 into A. Check if the Negative flag is set and print 'N' or 'P'.",
    "expected_response": "; Explicitly Check Negative Flag after LDA\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$95           ; Load $95 (%10010101)\n                       ; Bit 7 is 1, so LDA sets N=1.\n    BMI is_negative    ; Branch if N=1. Takes branch.\n\nis_positive:\n    LDA #'P'\n    printchar\n    JMP done\n\nis_negative:\n    LDA #'N'\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Decrement the value 1 using DEC zp targeting $10. Check if the Zero flag is set and print 'Z' or 'N'.",
    "expected_response": "; Explicitly Check Zero Flag after DEC zp\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nZP_DEC_VAL = $10\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #1\n    STA ZP_DEC_VAL     ; ZP $10 = 1\n\n    DEC ZP_DEC_VAL     ; Decrement ZP $10 (1 -> 0)\n                       ; DEC sets Z=1 because result is 0.\n    BEQ is_zero        ; Branch if Z=1. Takes branch.\n\nis_not_zero:\n    LDA #'N'\n    printchar\n    JMP done\n\nis_zero:\n    LDA #'Z'\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed for ZP in program area\n        .end"
  },
  {
    "user_prompt": "Perform ASL A on $C0. Check if the Carry flag is set and print 'C' or 'N'.",
    "expected_response": "; Explicitly Check Carry Flag after ASL A\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #$C0           ; Load %11000000\n    ASL A              ; Shift left. Bit 7(1) -> Carry. A becomes %10000000 ($80).\n                       ; ASL sets C=1.\n    BCS carry_set      ; Branch if C=1. Takes branch.\n\ncarry_clear:\n    LDA #'N'\n    printchar\n    JMP done\n\ncarry_set:\n    LDA #'C'\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Define a constant MAX_VALUE = 100. Load A with 90 and compare with MAX_VALUE. Print '<' if less.",
    "expected_response": "; Compare Accumulator with Defined Constant\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\nMAX_VALUE = 100\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #90            ; Load value 90\n    CMP #MAX_VALUE     ; Compare A (90) with 100\n                       ; 90 < 100, so C=0.\n    BCC is_less        ; Branch if Carry Clear (A < MAX_VALUE). Takes branch.\n\nis_ge:\n    LDA #'>'\n    printchar\n    LDA #'='\n    printchar\n    JMP done\n\nis_less:\n    LDA #'<'\n    printchar\n\ndone:\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  },
  {
    "user_prompt": "Reserve 10 bytes of memory using .res labelled 'my_buffer'.",
    "expected_response": "; Reserve Memory using .res Directive\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Example: Store something in the buffer\n    LDA #1\n    STA my_buffer+0\n    LDA #2\n    STA my_buffer+9\n    endprog\n\n; --- Data Storage ---\nmy_buffer: .res 10      ; Reserve 10 bytes of uninitialized memory\n\n        .end"
  },
   {
    "user_prompt": "Perform bitwise AND using zero page addressing. A=$F0, ZP location $80=$AA. Print result.",
    "expected_response": "; Bitwise AND with Zero Page Addressing (AND zp)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_MASK = $80\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize ZP value\n    LDA #$AA           ; %10101010\n    STA ZP_MASK\n\n    LDA #$F0           ; Load A = $F0 (%11110000)\n    AND ZP_MASK        ; AND A with value at ZP $80 ($AA)\n                       ; A = $F0 & $AA = %10100000 ($A0)\n    printnum           ; Print 160 ($A0)\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Perform bitwise ORA using absolute addressing. A=$03, location 'or_operand'=$C0. Print result.",
    "expected_response": "; Bitwise ORA with Absolute Addressing (ORA abs)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize memory value\n    LDA #$C0           ; %11000000\n    STA or_operand\n\n    LDA #$03           ; Load A = $03 (%00000011)\n    ORA or_operand     ; ORA A with value at 'or_operand' ($C0)\n                       ; A = $03 | $C0 = %00000011 | %11000000 = %11000011 ($C3)\n    printnum           ; Print 195 ($C3)\n    endprog\n\n; --- Data Storage ---\nor_operand: .res 1\n\n        .end"
  },
  {
    "user_prompt": "Perform bitwise EOR using zero page addressing. A=$FF, ZP location $55=$AA. Print result.",
    "expected_response": "; Bitwise EOR with Zero Page Addressing (EOR zp)\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n\nZP_VAL = $55\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    ; Initialize ZP value\n    LDA #$AA           ; %10101010\n    STA ZP_VAL\n\n    LDA #$FF           ; Load A = $FF (%11111111)\n    EOR ZP_VAL         ; EOR A with value at ZP $55 ($AA)\n                       ; A = $FF ^ $AA = %11111111 ^ %10101010 = %01010101 ($55)\n    printnum           ; Print 85 ($55)\n    endprog\n\n; No data storage needed in program area for ZP\n        .end"
  },
  {
    "user_prompt": "Print the string \"OK\" using immediate loads and printchar.",
    "expected_response": "; Print String \"OK\" Character by Character\n\n; --- Opcode Definitions ---\nprintnum_opcode   = $72\nprintchar_opcode  = $B2\nendprog_opcode    = $D2\n\n; --- Macros ---\n.macro printnum\n    .byte printnum_opcode\n.endmacro\n.macro printchar\n    .byte printchar_opcode\n.endmacro\n.macro endprog\n    .byte endprog_opcode\n.endmacro\n.macro newline\n    pha\n    lda #$0A\n    printchar\n    pla\n.endmacro\n\n        .org $0801\nstart:\n    LDX #$FF           ; Initialize stack pointer\n    TXS\n    LDA #'O'            ; Load ASCII 'O'\n    printchar\n    LDA #'K'            ; Load ASCII 'K'\n    printchar\n    newline\n    endprog\n\n; No data storage needed\n        .end"
  }
]